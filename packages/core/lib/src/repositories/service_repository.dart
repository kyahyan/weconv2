import 'package:models/models.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class ServiceRepository {
  ServiceRepository({SupabaseClient? client})
      : _client = client ?? Supabase.instance.client;

  final SupabaseClient _client;

  Future<List<Service>> getServices(DateTime start, DateTime end, {List<String>? orgIds, String? branchId}) async {
    var query = _client
        .from('services')
        .select()
        .gte('date', start.toIso8601String())
        .lte('date', end.toIso8601String()); // Use lte or lt? usually lte for inclusive

    if (orgIds != null && orgIds.isNotEmpty) {
      query = query.filter('organization_id', 'in', orgIds);
    }
    
    if (branchId != null) {
      query = query.eq('branch_id', branchId);
    }

    final response = await query.order('date');

    return (response as List).map((e) => Service.fromJson(e)).toList();
  }

  Future<Service> createService({
    required DateTime date,
    required String title,
    String? worshipLeaderId,
    DateTime? endTime,
    String? orgId,
    String? branchId,
  }) async {
    final response = await _client
        .from('services')
        .insert({
          'date': date.toUtc().toIso8601String(),
          'title': title,
          'worship_leader_id': worshipLeaderId,
          'end_time': endTime?.toUtc().toIso8601String(),
          if (orgId != null) 'organization_id': orgId,
          if (branchId != null) 'branch_id': branchId,
        })
        .select()
        .single();

    return Service.fromJson(response);
  }

  Future<void> deleteService(String id) async {
    await _client.from('services').delete().eq('id', id);
  }

  Future<bool> checkServiceConflict(DateTime start, DateTime end, {String? orgId, String? branchId}) async {
    // Check for overlap: (StartA < EndB) and (EndA > StartB)
    
    // Widen the search window to catch services that started previous day but overlap today
    // Query services starting between (Start - 24h) and (End)
    // Use UTC for consistent DB querying
    final queryStart = start.subtract(const Duration(hours: 24)).toUtc();
    final queryEnd = end.toUtc();
    
    // Debug Log
    print('DEBUG: Checking Conflict.');
    print('  Input Start: $start (isUtc: ${start.isUtc})');
    print('  Input End:   $end (isUtc: ${end.isUtc})');
    print('  Query Range: $queryStart to $queryEnd');

    var query = _client
        .from('services')
        .select()
        .gte('date', queryStart.toIso8601String())
        .lt('date', queryEnd.toIso8601String());

    if (orgId != null) query = query.eq('organization_id', orgId);
    if (branchId != null) query = query.eq('branch_id', branchId);

    final response = await query;
        
    final potentialConflicts = (response as List).map((e) => Service.fromJson(e)).toList();
    
    print('  Candidates Found: ${potentialConflicts.length}');

    for (final service in potentialConflicts) {
      final sStart = service.date;
      final sEnd = service.endTime ?? sStart.add(const Duration(hours: 2));
      
      print('    Candidate: "${service.title}"');
      print('      Start: $sStart (isUtc: ${sStart.isUtc})');
      print('      End:   $sEnd (isUtc: ${sEnd.isUtc})');
      
      // We assume strict overlap. 
      // Note: DateTime comparison handles mixed TimeZones (converts to UTC internally for comparison).
      final startsBeforeEnd = sStart.isBefore(end);
      final endsAfterStart = sEnd.isAfter(start);
      
      print('      sStart < end ? $startsBeforeEnd');
      print('      sEnd   > start ? $endsAfterStart');

      // Check for overlap
      if (startsBeforeEnd && endsAfterStart) {
        print('      -> CONFLICT DETECTED');
        return true; 
      }
    }
    
    return false;
  }
  Future<List<ServiceItem>> getServiceItems(String serviceId) async {
    final response = await _client
        .from('service_items')
        .select()
        .eq('service_id', serviceId)
        .order('order_index');
    return (response as List).map((e) => ServiceItem.fromJson(e)).toList();
  }

  Future<void> createServiceItem(ServiceItem item) async {
    // We ignore the ID as it is generated by DB
    await _client.from('service_items').insert({
      'service_id': item.serviceId,
      'title': item.title,
      'type': item.type, 
      'description': item.description,
      'duration_seconds': item.durationSeconds,
      'order_index': item.orderIndex,
      'song_id': item.songId,
      'assigned_to': item.assignedTo,
    });
  }

  Future<void> updateServiceItem(ServiceItem item) async {
    await _client.from('service_items').update({
      'title': item.title,
      'type': item.type,
      'description': item.description,
      'duration_seconds': item.durationSeconds,
      'order_index': item.orderIndex,
      'song_id': item.songId,
      'assigned_to': item.assignedTo,
    }).eq('id', item.id);
  }

  Future<void> deleteServiceItem(String itemId) async {
    await _client.from('service_items').delete().eq('id', itemId);
  }

  Future<void> updateServiceItemsOrder(List<ServiceItem> items) async {
    // Supabase supports upserting a list
    final updates = items.map((item) => {
      'id': item.id,
      'service_id': item.serviceId, // Required for constraint? check RLS/constraints
      'title': item.title,
      'order_index': item.orderIndex,
      // We must provide other non-nullable fields if it's an upsert on Primary Key? 
      // Actually update on PK only updates provided fields? No, upsert replaces unless specified?
      // Supabase upsert: "If the row exists, it updates it. If it doesn't, it inserts it."
      // Ideally we just want to update 'order_index'.
      // "upsert" might need all required columns.
      // Better to loop update? Or use a custom RPC?
      // Loop is safer for now for standard client. 
    }).toList();

    // Actually, let's just loop for safety and correctness to avoid overwriting data with partials.
    // Or use .upsert() with ignore duplicates? No.
    // We can use a single batch upsert if we map ALL fields.
    // But we might not want to fetch all fields just to update order.
    // Let's simply loop. It's rarely more than 10-20 items.
    
    // Optimization: Future.wait
    await Future.wait(items.map((item) => 
      _client.from('service_items').update({'order_index': item.orderIndex}).eq('id', item.id)
    ));
  }

  Future<List<ServiceAssignment>> getServiceAssignments(String serviceId) async {
    final response = await _client
        .from('service_assignments')
        .select()
        .eq('service_id', serviceId);
    return (response as List).map((e) => ServiceAssignment.fromJson(e)).toList();
  }

  Future<void> createServiceAssignment(ServiceAssignment assignment) async {
    await _client.from('service_assignments').insert({
      'service_id': assignment.serviceId,
      'member_id': assignment.memberId,
      'role_name': assignment.roleName,
      'confirmed': assignment.confirmed,
      'team_name': assignment.teamName,
    });
  }

  Future<void> deleteServiceAssignment(String id) async {
    await _client.from('service_assignments').delete().eq('id', id);
  }
}
